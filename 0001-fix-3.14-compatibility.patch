From 140c3d884273e4e98f8cf66592b399805e1916b4 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Per=20=C3=98yvind=20Karlsen=20=28proyvind=29?=
 <peroyvind@mandriva.org>
Date: Fri, 4 Jul 2014 21:44:36 +0200
Subject: [PATCH] fix 3.14 compatibility

---
 lib/include/vm_assert.h               |  1 +
 modules/linux/vmblock/linux/control.c | 34 +++++++++++++++++++++++++++++-----
 modules/linux/vmblock/linux/dentry.c  | 14 ++++++++++++++
 modules/linux/vmblock/linux/file.c    | 18 ++++++++++++++++++
 modules/linux/vmblock/linux/inode.c   | 15 ++++++++++++---
 modules/linux/vmci/linux/driver.c     |  2 +-
 modules/linux/vmhgfs/dir.c            |  2 +-
 modules/linux/vmhgfs/file.c           |  3 ++-
 modules/linux/vmhgfs/filesystem.c     |  4 ++--
 modules/linux/vmhgfs/fsutil.c         | 12 ++++++------
 modules/linux/vmhgfs/inode.c          | 25 +++++++++++++++++--------
 modules/linux/vmhgfs/link.c           |  6 +++---
 modules/linux/vmsync/sync.c           | 27 +++++++++++++++++++++++++--
 modules/linux/vsock/linux/af_vsock.c  |  2 +-
 14 files changed, 132 insertions(+), 33 deletions(-)

diff --git a/lib/include/vm_assert.h b/lib/include/vm_assert.h
index e806d93..25a26ee 100644
--- a/lib/include/vm_assert.h
+++ b/lib/include/vm_assert.h
@@ -288,6 +288,7 @@ void WarningThrottled(uint32 *count, const char *fmt, ...)
                                           __FILE__, __LINE__, __FUNCTION__, \
                                           _fix))
 #else
+   #undef DEPRECATED /* in <linux/printk.h> since 3.14.0 */
    #define DEPRECATED(_fix) do {} while (0)
 #endif
 
diff --git a/modules/linux/vmblock/linux/control.c b/modules/linux/vmblock/linux/control.c
index 79716bd..f3fb5be 100644
--- a/modules/linux/vmblock/linux/control.c
+++ b/modules/linux/vmblock/linux/control.c
@@ -208,17 +208,23 @@ SetupProcDevice(void)
    VMBlockSetProcEntryOwner(controlProcMountpoint);
 
    /* Create /proc/fs/vmblock/dev */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+   controlProcEntry = proc_create(VMBLOCK_CONTROL_DEVNAME, VMBLOCK_CONTROL_MODE, controlProcDirEntry, &ControlFileOps);
+#else
    controlProcEntry = create_proc_entry(VMBLOCK_CONTROL_DEVNAME,
                                         VMBLOCK_CONTROL_MODE,
                                         controlProcDirEntry);
-   if (!controlProcEntry) {
+#endif
+   if (controlProcEntry == NULL) {
       Warning("SetupProcDevice: could not create " VMBLOCK_DEVICE "\n");
       remove_proc_entry(VMBLOCK_CONTROL_MOUNTPOINT, controlProcDirEntry);
       remove_proc_entry(VMBLOCK_CONTROL_PROC_DIRNAME, NULL);
       return -EINVAL;
    }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 10, 0)
    controlProcEntry->proc_fops = &ControlFileOps;
+#endif
    return 0;
 }
 
@@ -278,22 +284,40 @@ ExecuteBlockOp(const char __user *buf,                // IN: buffer with name
                int (*blockOp)(const char *filename,   // IN: block operation
                               const os_blocker_id_t blocker))
 {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 7, 0)
+   struct filename *fname;
+#else
+   char *fname;
+#endif
    char *name;
    int i;
    int retval;
 
-   name = getname(buf);
-   if (IS_ERR(name)) {
-      return PTR_ERR(name);
+   fname = __getname();
+   if (IS_ERR(fname)) {
+      return PTR_ERR(fname);
+   }
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+   i = strncpy_from_user(name, buf, PATH_MAX);
+   if (i < 0 || i == PATH_MAX) {
+      __putname(name);
+      return -EINVAL;
    }
+#endif
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 7, 0)
+   name = (char *)fname->name;
+#else
+   name = fname;
+#endif
    for (i = strlen(name) - 1; i >= 0 && name[i] == '/'; i--) {
       name[i] = '\0';
    }
 
    retval = i < 0 ? -EINVAL : blockOp(name, blocker);
 
-   putname(name);
+   __putname(name);
 
    return retval;
 }
diff --git a/modules/linux/vmblock/linux/dentry.c b/modules/linux/vmblock/linux/dentry.c
index 05ea95a..3d43c5e 100644
--- a/modules/linux/vmblock/linux/dentry.c
+++ b/modules/linux/vmblock/linux/dentry.c
@@ -32,7 +32,11 @@
 #include "block.h"
 
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
+static int DentryOpRevalidate(struct dentry *dentry, unsigned int flags);
+#else
 static int DentryOpRevalidate(struct dentry *dentry, struct nameidata *nd);
+#endif
 
 struct dentry_operations LinkDentryOps = {
    .d_revalidate = DentryOpRevalidate,
@@ -58,9 +62,15 @@ struct dentry_operations LinkDentryOps = {
  *----------------------------------------------------------------------------
  */
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
+static int
+DentryOpRevalidate(struct dentry *dentry,  // IN: dentry revalidating
+                   unsigned int flags)     // IN: lookup flags
+#else
 static int
 DentryOpRevalidate(struct dentry *dentry,  // IN: dentry revalidating
                    struct nameidata *nd)   // IN: lookup flags & intent
+#endif
 {
    VMBlockInodeInfo *iinfo;
    struct nameidata actualNd;
@@ -101,7 +111,11 @@ DentryOpRevalidate(struct dentry *dentry,  // IN: dentry revalidating
    if (actualDentry &&
        actualDentry->d_op &&
        actualDentry->d_op->d_revalidate) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
+      return actualDentry->d_op->d_revalidate(actualDentry, flags);
+#else
       return actualDentry->d_op->d_revalidate(actualDentry, nd);
+#endif
    }
 
    if (compat_path_lookup(iinfo->name, 0, &actualNd)) {
diff --git a/modules/linux/vmblock/linux/file.c b/modules/linux/vmblock/linux/file.c
index d7ac1f6..513f2d5 100644
--- a/modules/linux/vmblock/linux/file.c
+++ b/modules/linux/vmblock/linux/file.c
@@ -38,6 +38,7 @@ typedef u64 inode_num_t;
 typedef ino_t inode_num_t;
 #endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 11, 0)
 /* Specifically for our filldir_t callback */
 typedef struct FilldirInfo {
    filldir_t filldir;
@@ -76,6 +77,7 @@ Filldir(void *buf,              // IN: Dirent buffer passed from FileOpReaddir
    /* Specify DT_LNK regardless */
    return info->filldir(info->dirent, name, namelen, offset, ino, DT_LNK);
 }
+#endif
 
 
 /* File operations */
@@ -164,13 +166,21 @@ FileOpOpen(struct inode *inode,  // IN
  *----------------------------------------------------------------------------
  */
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 11, 0)
+static int
+FileOpIterate(struct file *file,  // IN
+              struct dir_context *ctx)  // IN
+#else
 static int
 FileOpReaddir(struct file *file,  // IN
               void *dirent,       // IN
               filldir_t filldir)  // IN
+#endif
 {
    int ret;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 11, 0)
    FilldirInfo info;
+#endif
    struct file *actualFile;
 
    if (!file) {
@@ -184,12 +194,16 @@ FileOpReaddir(struct file *file,  // IN
       return -EINVAL;
    }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 11, 0)
+   ret = iterate_dir(actualFile, ctx);
+#else
    info.filldir = filldir;
    info.dirent = dirent;
 
    actualFile->f_pos = file->f_pos;
    ret = vfs_readdir(actualFile, Filldir, &info);
    file->f_pos = actualFile->f_pos;
+#endif
 
    return ret;
 }
@@ -237,7 +251,11 @@ FileOpRelease(struct inode *inode, // IN
 
 
 struct file_operations RootFileOps = {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 11, 0)
+   .iterate = FileOpIterate,
+#else
    .readdir = FileOpReaddir,
+#endif
    .open    = FileOpOpen,
    .release = FileOpRelease,
 };
diff --git a/modules/linux/vmblock/linux/inode.c b/modules/linux/vmblock/linux/inode.c
index 098c94c..77bd12e 100644
--- a/modules/linux/vmblock/linux/inode.c
+++ b/modules/linux/vmblock/linux/inode.c
@@ -36,7 +36,11 @@
 
 /* Inode operations */
 static struct dentry *InodeOpLookup(struct inode *dir,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
+                                    struct dentry *dentry, unsigned int flags);
+#else
                                     struct dentry *dentry, struct nameidata *nd);
+#endif
 static int InodeOpReadlink(struct dentry *dentry, char __user *buffer, int buflen);
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 13)
 static void *InodeOpFollowlink(struct dentry *dentry, struct nameidata *nd);
@@ -75,7 +79,11 @@ static struct inode_operations LinkInodeOps = {
 static struct dentry *
 InodeOpLookup(struct inode *dir,      // IN: parent directory's inode
               struct dentry *dentry,  // IN: dentry to lookup
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
+              unsigned int flags)     // IN: lookup flags
+#else
               struct nameidata *nd)   // IN: lookup intent and information
+#endif
 {
    char *filename;
    struct inode *inode;
@@ -135,7 +143,8 @@ InodeOpLookup(struct inode *dir,      // IN: parent directory's inode
    inode->i_size = INODE_TO_IINFO(inode)->nameLen;
    inode->i_version = 1;
    inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
-   inode->i_uid = inode->i_gid = 0;
+   inode->i_uid = KUIDT_INIT(0);
+   inode->i_gid = KGIDT_INIT(0);
    inode->i_op = &LinkInodeOps;
 
    d_add(dentry, inode);
@@ -206,7 +215,7 @@ static int
 InodeOpFollowlink(struct dentry *dentry,  // IN : dentry of symlink
                   struct nameidata *nd)   // OUT: stores result
 {
-   int ret;
+   int ret = 0;
    VMBlockInodeInfo *iinfo;
 
    if (!dentry) {
@@ -221,7 +230,7 @@ InodeOpFollowlink(struct dentry *dentry,  // IN : dentry of symlink
       goto out;
    }
 
-   ret = vfs_follow_link(nd, iinfo->name);
+   nd_set_link(nd, iinfo->name);
 
 out:
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 13)
diff --git a/modules/linux/vmci/linux/driver.c b/modules/linux/vmci/linux/driver.c
index 79128dc..7c06731 100644
--- a/modules/linux/vmci/linux/driver.c
+++ b/modules/linux/vmci/linux/driver.c
@@ -737,7 +737,7 @@ LinuxDriver_Ioctl(struct inode *inode,
          goto init_release;
       }
 
-      user = current_uid();
+      user = from_kuid(current_user_ns(), current_uid());
       retval = VMCIContext_InitContext(initBlock.cid, initBlock.flags,
                                        0 /* Unused */, vmciLinux->userVersion,
                                        &user, &vmciLinux->context);
diff --git a/modules/linux/vmhgfs/dir.c b/modules/linux/vmhgfs/dir.c
index 1d0351a..2126117 100644
--- a/modules/linux/vmhgfs/dir.c
+++ b/modules/linux/vmhgfs/dir.c
@@ -79,7 +79,7 @@ struct file_operations HgfsDirFileOperations = {
    .owner       = THIS_MODULE,
    .open        = HgfsDirOpen,
    .read        = generic_read_dir,
-   .readdir     = HgfsReaddir,
+   .iterate     = HgfsReaddir,
    .release     = HgfsDirRelease,
 };
 
diff --git a/modules/linux/vmhgfs/file.c b/modules/linux/vmhgfs/file.c
index 3568f4a..2bf0487 100644
--- a/modules/linux/vmhgfs/file.c
+++ b/modules/linux/vmhgfs/file.c
@@ -656,7 +656,8 @@ HgfsOpen(struct inode *inode,  // IN: Inode of the file to open
             iparent = dparent->d_inode;
 
             HgfsSetUidGid(iparent, file->f_dentry,
-                          current_fsuid(), current_fsgid());
+                        from_kuid(current_user_ns(), current_fsuid()),
+                        from_kgid(current_user_ns(), current_fsgid()));
 
             dput(dparent);
          }
diff --git a/modules/linux/vmhgfs/filesystem.c b/modules/linux/vmhgfs/filesystem.c
index f101ca7..160f25f 100644
--- a/modules/linux/vmhgfs/filesystem.c
+++ b/modules/linux/vmhgfs/filesystem.c
@@ -231,13 +231,13 @@ HgfsInitSuperInfo(HgfsMountInfo *mountInfo) // IN: Passed down from the user
    if (si->uidSet) {
       si->uid = mountInfo->uid;
    } else {
-      si->uid = current_uid();
+      si->uid = from_kuid(current_user_ns(), current_uid());
    }
    si->gidSet = mountInfo->gidSet;
    if (si->gidSet) {
       si->gid = mountInfo->gid;
    } else {
-      si->gid = current_gid();
+      si->gid = from_kgid(current_user_ns(), current_gid());
    }
    si->fmask = mountInfo->fmask;
    si->dmask = mountInfo->dmask;
diff --git a/modules/linux/vmhgfs/fsutil.c b/modules/linux/vmhgfs/fsutil.c
index a978005..2e48cd0 100644
--- a/modules/linux/vmhgfs/fsutil.c
+++ b/modules/linux/vmhgfs/fsutil.c
@@ -639,14 +639,14 @@ HgfsChangeFileAttributes(struct inode *inode,          // IN/OUT: Inode
     * the server didn't give us a uid or gid.
     */
    if (si->uidSet || (attr->mask & HGFS_ATTR_VALID_USERID) == 0) {
-      inode->i_uid = si->uid;
+      inode->i_uid = make_kuid(current_user_ns(), si->uid);
    } else {
-      inode->i_uid = attr->userId;
+      inode->i_uid = make_kuid(current_user_ns(), attr->userId);
    }
    if (si->gidSet || (attr->mask & HGFS_ATTR_VALID_GROUPID) == 0) {
-      inode->i_gid = si->gid;
+      inode->i_gid = make_kgid(current_user_ns(), si->gid);
    } else {
-      inode->i_gid = attr->groupId;
+      inode->i_gid = make_kgid(current_user_ns(), attr->groupId);
    }
 
    inode->i_rdev = 0;  /* Device nodes are not supported */
@@ -1623,7 +1623,7 @@ HgfsSetUidGid(struct inode *parent,     // IN: parent inode
    struct iattr setUidGid;
 
    setUidGid.ia_valid = ATTR_UID;
-   setUidGid.ia_uid = uid;
+   setUidGid.ia_uid = make_kuid(current_user_ns(), uid);
 
    /*
     * Only set the gid if the host file system wouldn't have for us.  See the
@@ -1631,7 +1631,7 @@ HgfsSetUidGid(struct inode *parent,     // IN: parent inode
     */
    if (!parent || !(parent->i_mode & S_ISGID)) {
       setUidGid.ia_valid |= ATTR_GID;
-      setUidGid.ia_gid = gid;
+      setUidGid.ia_gid = make_kgid(current_user_ns(), gid);
    }
 
    /*
diff --git a/modules/linux/vmhgfs/inode.c b/modules/linux/vmhgfs/inode.c
index 60bb31a..65ad65a 100644
--- a/modules/linux/vmhgfs/inode.c
+++ b/modules/linux/vmhgfs/inode.c
@@ -31,6 +31,9 @@
 #include <linux/namei.h>
 #endif
 #include <linux/highmem.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 11, 0)
+#include <linux/dcache.h>
+#endif
 
 #include "compat_cred.h"
 #include "compat_fs.h"
@@ -487,13 +490,13 @@ HgfsPackSetattrRequest(struct iattr *iattr,   // IN: Inode attrs to update from
 
       if (valid & ATTR_UID) {
          attrV2->mask |= HGFS_ATTR_VALID_USERID;
-         attrV2->userId = iattr->ia_uid;
+         attrV2->userId = from_kuid(current_user_ns(), iattr->ia_uid);
          *changed = TRUE;
       }
 
       if (valid & ATTR_GID) {
          attrV2->mask |= HGFS_ATTR_VALID_GROUPID;
-         attrV2->groupId = iattr->ia_gid;
+         attrV2->groupId = from_kgid(current_user_ns(), iattr->ia_gid);
          *changed = TRUE;
       }
 
@@ -590,13 +593,13 @@ HgfsPackSetattrRequest(struct iattr *iattr,   // IN: Inode attrs to update from
 
       if (valid & ATTR_UID) {
          attrV2->mask |= HGFS_ATTR_VALID_USERID;
-         attrV2->userId = iattr->ia_uid;
+         attrV2->userId = from_kuid(current_user_ns(), iattr->ia_uid);
          *changed = TRUE;
       }
 
       if (valid & ATTR_GID) {
          attrV2->mask |= HGFS_ATTR_VALID_GROUPID;
-         attrV2->groupId = iattr->ia_gid;
+         attrV2->groupId = from_kgid(current_user_ns(), iattr->ia_gid);
          *changed = TRUE;
       }
 
@@ -1189,7 +1192,7 @@ HgfsMkdir(struct inode *dir,     // IN: Inode of parent directory
              * a Linux machine and as root, but we might as well give it
              * a go.
              */
-            HgfsSetUidGid(dir, dentry, current_fsuid(), current_fsgid());
+            HgfsSetUidGid(dir, dentry, current_fsuid().val, current_fsgid().val);
          }
 
          /*
@@ -1838,7 +1841,11 @@ HgfsPermission(struct inode *inode,
 #endif
                            &inode->i_dentry,
                            d_alias) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 11, 0)
+         int dcount = d_count(dentry);
+#else
          int dcount = dentry->d_count;
+#endif
          if (dcount) {
             LOG(4, ("Found %s %d \n", dentry->d_name.name, dcount));
             return HgfsAccessInt(dentry, mask & (MAY_READ | MAY_WRITE | MAY_EXEC));
@@ -1891,10 +1898,12 @@ HgfsPermission(struct inode *inode,
       list_for_each(pos, &inode->i_dentry) {
          int dcount;
          struct dentry *dentry = list_entry(pos, struct dentry, d_alias);
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 38)
-         dcount = atomic_read(&dentry->d_count);
-#else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 11, 0)
+         dcount = d_count(dentry);
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 38)
          dcount = dentry->d_count;
+#else
+         dcount = atomic_read(&dentry->d_count);
 #endif
          if (dcount) {
             LOG(4, ("Found %s %d \n", (dentry)->d_name.name, dcount));
diff --git a/modules/linux/vmhgfs/link.c b/modules/linux/vmhgfs/link.c
index 9fb95a5..d1c809a 100644
--- a/modules/linux/vmhgfs/link.c
+++ b/modules/linux/vmhgfs/link.c
@@ -88,7 +88,7 @@ HgfsFollowlink(struct dentry *dentry, // IN: Dentry containing link
 {
    HgfsAttrInfo attr;
    char *fileName = NULL;
-   int error;
+   int error = 0;
 
    ASSERT(dentry);
    ASSERT(nd);
@@ -111,8 +111,8 @@ HgfsFollowlink(struct dentry *dentry, // IN: Dentry containing link
          error = -EINVAL;
       } else {
          LOG(6, (KERN_DEBUG "VMware hgfs: HgfsFollowlink: calling "
-                 "vfs_follow_link\n"));
-         error = vfs_follow_link(nd, fileName);
+                 "nd_set_link\n"));
+	 nd_set_link(nd, fileName);
       }
       kfree(fileName);
    }
diff --git a/modules/linux/vmsync/sync.c b/modules/linux/vmsync/sync.c
index d05ccad..c0f170b 100644
--- a/modules/linux/vmsync/sync.c
+++ b/modules/linux/vmsync/sync.c
@@ -162,7 +162,11 @@ VmSyncThawDevices(void  *_state)  // IN
    cancel_delayed_work(&state->thawTask);
    list_for_each_safe(cur, tmp, &state->devices) {
       dev = list_entry(cur, VmSyncBlockDevice, list);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
+      if (dev->sb != NULL && dev->sb->s_writers.frozen != SB_UNFROZEN) {
+#else
       if (dev->sb != NULL && dev->sb->s_frozen != SB_UNFROZEN) {
+#endif
          thaw_bdev(dev->bdev, dev->sb);
          atomic_dec(&gFreezeCount);
       }
@@ -237,7 +241,11 @@ VmSyncAddPath(const VmSyncState *state,   // IN
     * the superblock is already frozen.
     */
    if (inode->i_sb->s_bdev == NULL ||
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
+       inode->i_sb->s_writers.frozen != SB_UNFROZEN) {
+#else
        inode->i_sb->s_frozen != SB_UNFROZEN) {
+#endif
       result = (inode->i_sb->s_bdev == NULL) ? -EINVAL : -EALREADY;
       compat_path_release(&nd);
       goto exit;
@@ -303,7 +311,11 @@ VmSyncFreezeDevices(VmSyncState *state,            // IN
                     const char __user *userPaths)  // IN
 {
    int result = 0;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 7, 0)
+   struct filename *paths;
+#else
    char *paths;
+#endif
    char *currPath;
    char *nextSep;
    struct list_head *cur, *tmp;
@@ -317,7 +329,7 @@ VmSyncFreezeDevices(VmSyncState *state,            // IN
     * Although this is not ideal, it shouldn't be a problem. We need an
     * upper bound anyway.
     */
-   paths = getname(userPaths);
+   paths = __getname();
    if (IS_ERR(paths)) {
       return PTR_ERR(paths);
    }
@@ -328,7 +340,11 @@ VmSyncFreezeDevices(VmSyncState *state,            // IN
    /*
     * First, try to add all paths to the list of paths to be frozen.
     */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 7, 0)
+   currPath = (char *)paths->name;
+#else
    currPath = paths;
+#endif
    do {
       nextSep = strchr(currPath, ':');
       if (nextSep != NULL) {
@@ -670,17 +686,24 @@ init_module(void)
    }
 
    /* Create /proc/driver/vmware-sync */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+   controlProcEntry = proc_create("driver/vmware-sync", S_IFREG | S_IRUSR | S_IRGRP | S_IROTH,
+				  NULL, &VmSyncFileOps);
+#else
    controlProcEntry = create_proc_entry("driver/vmware-sync",
                                         S_IFREG | S_IRUSR | S_IRGRP | S_IROTH,
                                         NULL);
-   if (!controlProcEntry) {
+#endif
+   if (controlProcEntry == NULL) {
       printk(KERN_ERR "vmsync: could not create /proc/driver/vmware-sync\n");
       kmem_cache_destroy(gSyncStateCache);
       kmem_cache_destroy(gBlockDeviceCache);
       return -EINVAL;
    }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 10, 0)
    controlProcEntry->proc_fops = &VmSyncFileOps;
+#endif
    return 0;
 }
 
diff --git a/modules/linux/vsock/linux/af_vsock.c b/modules/linux/vsock/linux/af_vsock.c
index cc07cec..a487f17 100644
--- a/modules/linux/vsock/linux/af_vsock.c
+++ b/modules/linux/vsock/linux/af_vsock.c
@@ -3147,7 +3147,7 @@ __VSockVmciCreate(struct net *net,       // IN: Network namespace
       vsk->connectTimeout = psk->connectTimeout;
    } else {
       vsk->trusted = capable(CAP_NET_ADMIN);
-      vsk->owner = current_uid();
+      vsk->owner = from_kuid(current_user_ns(), current_uid());
       vsk->queuePairSize = VSOCK_DEFAULT_QP_SIZE;
       vsk->queuePairMinSize = VSOCK_DEFAULT_QP_SIZE_MIN;
       vsk->queuePairMaxSize = VSOCK_DEFAULT_QP_SIZE_MAX;
-- 
1.9.0

